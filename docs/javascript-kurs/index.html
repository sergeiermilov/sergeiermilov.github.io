<!doctype html>
<html lang="ru">
  <head>
    <!-- Required meta tags -->
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

	<link rel="apple-touch-icon" sizes="180x180" href="../../assets/icons/apple-touch-icon.png">
	<link rel="icon" type="image/png" sizes="32x32" href="../../assets/icons/favicon-32x32.png">
	<link rel="icon" type="image/png" sizes="16x16" href="../../assets/icons/favicon-16x16.png">
	<link rel="manifest" href="../../assets/icons/site.webmanifest">
	<link rel="mask-icon" href="../../assets/icons/safari-pinned-tab.svg" color="#787878">
	<meta name="msapplication-TileColor" content="#ffffff">
	<meta name="theme-color" content="#ffffff">

  	<!-- Bootstrap CSS -->
  	<link rel="stylesheet" href="../../assets/css/bootstrap.min.css">
	<link rel="stylesheet" href="../../assets/css/prism.css">
	<link rel="stylesheet" href="../../assets/css/style.css">

    <title>Курс JavaScript для начинающих &#8212; SergeiErmilov</title>
  </head>
<body class="position-relative">
	<!-- Yandex.Metrika counter -->
	<script type="text/javascript">
		(function(m,e,t,r,i,k,a){
			m[i]=m[i]||function(){(m[i].a=m[i].a||[]).push(arguments)};
			m[i].l=1*new Date();
			for (var j = 0; j < document.scripts.length; j++) {if (document.scripts[j].src === r) { return; }}
			k=e.createElement(t),a=e.getElementsByTagName(t)[0],k.async=1,k.src=r,a.parentNode.insertBefore(k,a)
		})(window, document,'script','https://mc.yandex.ru/metrika/tag.js?id=104047655', 'ym');

		ym(104047655, 'init', {ssr:true, webvisor:true, clickmap:true, ecommerce:"dataLayer", accurateTrackBounce:true, trackLinks:true});
	</script>
	<noscript><div><img src="https://mc.yandex.ru/watch/104047655" style="position:absolute; left:-9999px;" alt="" /></div></noscript>
	<!-- /Yandex.Metrika counter -->   

<!-- navbar section -->
<section class="navbar-section">
	<nav class="navbar navbar-expand-lg navbar-light bg-white">
		<div class="container">
			<a class="navbar-brand d-flex gap-3 align-items-center" href="../../">
				<img src="../../assets/images/sergei-150.png" alt="" width="80" height="80" class="d-inline-block align-middle">
				<div class="logo-block"><span class="fw-bold">Фронтенд</span><br><span class="small-font">Сергей Ермилов</span></div>
			</a>
			<button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
				<span class="navbar-toggler-icon"></span>
			</button>
			<div class="collapse navbar-collapse" id="navbarSupportedContent">
				<ul class="navbar-nav ms-0 ms-md-5 mb-2 mb-lg-0">

					<li class="nav-item">
						<a class="nav-link" title="GitHub" target="_blank" href="https://github.com/uzabila"><img src="../../assets/images/gh.svg" alt="GitHub" width="32" height="32" class="mx-3" style="margin-top:-5px"></a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../about/">Обо мне</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../services/">Услуги</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../portfolio/">Портфолио</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../docs/">Доки</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../terms/">Термины</a>
					</li>

					<li class="nav-item">
						<a class="nav-link" href="../../tools/">Инструменты</a>
					</li>
					
					<li class="nav-item">
						<a class="nav-link" href="../../book/">Книга</a>
					</li>
		
					<li class="nav-item">
						<a class="nav-link" href="../../contacts/">Контакты</a>
					</li>
			</div>
		</div>
	</nav>
</section>
<!-- ---------- --> 
<!-- END HEADER -->
<!-- ---------- -->

<div class="container-fluid">
	<div class="row mb-3 mb-md-4 mb-lg-5">

		<div class="col-12 col-lg-3">

<div class="content-blocks bg-light p-3">
	
	<div>
        <b>Содержание</b>
	</div>

    <div>
		<span>1</span> <a href="#Vvedenie"><span>Введение</span></a>
    </div>
	<div>
		<span>2</span> <a href="#Osnovy"><span>Основы</span></a>
    </div>
	<div>
		<span>3</span> <a href="#Stroki"><span>Строки</span></a>
	</div>
	<div>
		<span>4</span> <a href="#Znacenia_i_peremennye"><span>Значения и переменные</span></a>
    </div>
	<div>
		<span>5</span> <a href="#Prevrasaaem_desaticnoe_cislo_v_celoe"><span>Превращаяем десятичное число в целое</span></a>
    </div>
	<div>
		<span>6</span> <a href="#Funkcii"><span>Функции</span></a>
    </div>
	<div>
		<span>7</span> <a href="#Standartnaa_biblioteka"><span>«Стандартная библиотека»</span></a>
    </div>
	<div>
		<span>8</span> <a href="#Storonnij_JavaScript"><span>Сторонний JavaScript</span></a>
    </div>
	<div>
		<span>9</span> <a href="#Sozdanie_novyh_funkcij"><span>Создание новых функций</span></a>
    </div>
	<div>
		<span>10</span> <a href="#Cikly"><span>Циклы</span></a>
    </div>
	
	<div>		
		<span>11</span> <a href="#Massivy"> <span>Массивы</span></a>
    	<div class="px-3 pt-2">
			<div>
				<span>11.1</span> <a href="#Udalenie_dublikatov_iz_massiva"><span>Удаление дубликатов из массива</span></a>
			</div>
			<div>
				<span>11.2</span> <a href="#Polucenie_poslednego_znacenia_massiva"><span>Получение последнего значения массива</span></a>
			</div>
			<div>
				<span>11.3</span> <a href="#Polucenie_slucajnogo_znacenia_indeksa_iz_massiva"><span>Получение случайного значения индекса из массива</span></a>
			</div>
			<div>
				<span>11.4</span> <a href="#Obnaruzenie_samogo_dlinnogo_slova_v_massive"><span>Обнаружение самого длинного слова в массиве</span></a>
			</div>
		</div>
	</div>	
	<div>
		<span>12</span> <a href="#Obekty"><span>Объекты</span></a>
    </div>
	<div>
		<span>13</span> <a href="#Callbacks"><span>Callbacks</span></a>
    </div>
	<div>
		<span>14</span> <a href="#Snippety"><span>Сниппеты</span></a>
    	<div class="px-3 pt-2">
			<div>
				<span>14.1</span> <a href="#Proveraem_susestvovanie_funkcii"><span>Проверяем существование функции</span></a>
			</div>
			<div>
				<span>14.2</span> <a href="#Zamenaem_element_massiva"><span>Заменяем элемент массива</span></a>
			</div>
		</div>
	</div>
	<div>
		<span>15</span> <a href="#Zaklucenie"><span>Заключение</span></a>
    </div>
</div>
		</div>


		<div class="col-12 col-lg-9 single-content-column">
			<p><a href="../" class="link-secondary">Доки</a></p>
			<h1 class="fw-600">Курс JavaScript для начинающих</h1>

<p>Основы языка программирования Javascript для новичков, всё что необходимо знать в самом начале изучения языка — переменные, функции и многое другое.</p>

<h2><span id="Vvedenie">Введение</span></h2>

<p>JavaScript — это язык программирования или, другими словами, средство, с помощью которого компьютер получает инструкции.</p>

<p>JavaScript – это легкий интерпретируемый язык программирования. Он предназначен для создания сетевых приложений. Он бесплатный и интегрирован с Java. JavaScript очень легко реализовать, потому что он интегрирован с HTML. Это открытый и кроссплатформенный язык программирования.</p>

<p>Точно так же, как, например, кошки контролируют людей шипением и мяуканьем, человек управляет компьютерами с помощью утверждений, написанных на языке программирования. Все веб-браузеры понимают JavaScript и вы можете воспользоваться этим, чтобы веб-страницы делали сумасшедшие вещи!</p>

<p>Он легкий и чаще всего используется как часть веб-страниц, реализации которых позволяют клиентскому сценарию взаимодействовать с пользователем и создавать динамические страницы. Это интерпретируемый язык программирования с объектно-ориентированными возможностями.</p>

<p>JavaScript начинался как способ сделать веб-страницы более интерактивными. В настоящее время JavaScript работает в большем количестве мест, чем просто веб-браузеры — он работает на веб-серверах, телефонах и даже робототехнике! Этот материал научит вас некоторым основам JavaScript, чтобы вы могли быстро приступить к работе.</p>

<p>Как и кошки вы всегда будете приземляться на ноги даже при программировании! В отличие от разбрызгивания стакана воды над вашим ноутбуком, это руководство никак не повредит вашему компьютеру, даже если вы неправильно наберете команду или нажмете не ту кнопку.</p>

<p>Как и кошки, компьютерные программисты постоянно совершают ошибки: неправильно пишут, забывают кавычки или скобки и забывают о том, как работают основные функции. Программисты больше заботятся о том, чтобы заставить всё работать в конечном итоге, а не пытаются заставить всё работать с первого раза.</p>

<p>Лучший способ учиться — это учиться на ошибках!</p>

<p>Так что не будьте испуганным котом! Самое худшее, что может произойти, это то, что вам, возможно, придется обновить эту страницу в веб-браузере, если вы застряли. Не волнуйтесь, это случается очень редко.</p>

<h2><span id="Osnovy">Основы</span></h2>

<p>На этой странице сейчас работает JavaScript. Давайте немного поиграемся с этим. Для простоты я предполагаю, что вы используете Google Chrome для чтения этой страницы (если вы этого не сделаете, возможно, нам обоим будет легче, если вы будете всё делать именно в Chrome).</p>

<p>Сначала щелкните правой кнопкой мыши в любом месте экрана и нажмите «Просмотреть код» (<strong>Inspect Element</strong>), затем перейдите на вкладку «Консоль» (<strong>Console</strong>). Вы должны увидеть что-то похожее на это:</p>

<div>
<figure><img src="images/console.gif" alt="" class="img-fluid"></figure></div>

<p>Это консоль, иначе называемая «командной строкой» (<strong>command line</strong>) или «терминалом» (<strong>terminal</strong>). По сути, это способ ввести одну команду за раз в компьютер и немедленно получить ответ. Она очень полезна в качестве инструмента обучения (я все еще использую консоль почти каждый день, когда пишу код).</p>

<p>Консоль делает довольно интересные вещи. Здесь я начал что-то печатать, и консоль помогает мне, давая мне список всех возможных подсказок, которые я мог бы продолжать печатать! Еще одна вещь, которую вы можете сделать, это набрать 1 + 1 в консоли, а затем нажать клавишу Enter и посмотреть, что произойдет.</p>

<p>Использование консоли является очень важной частью изучения JavaScript. Если вы не знаете, работает ли что-то или для чего предназначена команда, перейдите к консоли и выясните это! Ниже будет много примеров.</p>

<h2><span id="Stroki">Строки</span></h2>

<p>Поскольку я кошка, я хочу заменить каждое встречающееся слово <code>dog</code> в Интернете на <code>those blasted dogs</code> (эти проклятые собаки).</p>

<p>Сначала зайдите в консоль и введите несколько предложений, которые содержат слово <code>dog</code> хотя бы один раз. В JavaScript связка букв, цифр, слов или чего-либо еще называется строкой (<strong>string</strong>). Строки должны начинаться и заканчиваться кавычкой. Неважно, будет это одиночная кавычка <code>'</code> или двойная <code>"</code>, просто убедитесь, что вы используете одинаковые кавычки в начале и в конце.</p>

<div>
<figure><img src="images/console-strings.gif" alt="" class="img-fluid"></figure></div>

<p>Видите неприятное сообщение об ошибке выше? Не волнуйтесь — вы не нарушили никаких законов. <strong>SyntaxError</strong> ILLEGAL — это роботы сообщают вам, что у вашей программы есть проблема. Первые два предложения имели одинаковые кавычки в начале и в конце, но когда я смешал одинарные и двойные кавычки, то появилась ошибка.</p>

<p>Хорошо, чтобы исправить одно из этих предложений (заменив <code>dog</code> нашей улучшенной версией), мы должны сначала сохранить оригинальное предложение, чтобы мы могли вызвать его позже, когда будем использовать магию замены. Заметьте, как строка повторяется красным, когда мы вводим ее в консоль? Это потому, что мы не сказали, чтобы она сохранило предложение где-либо, поэтому оно просто возвращает его обратно (или возвращает ошибку, если мы что-то испортили).</p>

<h2><span id="Znacenia_i_peremennye">Значения и переменные</span></h2>

<p>Значения являются простейшими компонентами в JavaScript. <code>1</code> — это значение, <code>true</code> — это значение, <code>hello</code> — это значение, <code>function() {}</code> — это значение, список можно продолжить! В JavaScript есть несколько разных типов значений, но нам не нужно сразу все их пересматривать — вы узнаете их, естественно, чем больше вы будете кодить!</p>

<p>Для хранения значений мы используем штуки, называемые переменными (<strong>variables</strong>). Слово «переменная» означает «может меняться» и используется потому, что переменные могут хранить много разных типов значений и могут много раз изменять их значения. Они очень похожи на почтовые ящики. </p>

<p>Мы помещаем что-то в переменную, например, наше предложение, а затем присваиваем переменной адрес, который мы можем использовать для поиска предложения позже. В реальной жизни почтовые ящики должны иметь номера почтового ящика, но в JavaScript вы обычно просто используете строчные буквы или цифры без пробелов.</p>

<div>
<figure><img src="images/console-variables.gif" alt="" class="img-fluid"></figure></div>

<p><code>var</code> — это сокращение от английского слова variable — переменная, а <code>=</code> означает, что штука с правой стороны хранится в штуке с левой стороны. Также, как вы можете увидеть теперь что, когда мы сохраняем наше предложение в переменной, консоль не просто сразу возвращает наше предложение, но вместо этого дает нам <code>undefined</code>, что означает, что возвращать нечего.</p>

<p>Если вы просто введете имя переменной в консоль, она выведет значение, хранящееся в этой переменной. Отдельно стоит заметить про переменные, что по умолчанию они исчезают при переходе на другую страницу. </p>

<p>Например, если бы я нажал кнопку «Обновить» (<strong>Refresh</strong>) в Chrome, моя переменная <code>dogSentence</code> была бы стерта и она бы больше никогда не существовала. Но пока не беспокойтесь об этом — вы можете просто нажимать стрелки вверх или вниз на клавиатуре, пока находитесь в консоли, чтобы просмотреть все, что вы недавно вводили.</p>

<h2><span id="Prevrasaaem_desaticnoe_cislo_v_celoe">Превращаяем десятичное число в целое</span></h2>

<p>Это довольно простой трюк.</p>

<pre><code class="language-javascript">const number = 23.6565
console.log(number | 0);</code></pre>

<h2><span id="Funkcii">Функции</span></h2>

<p>Теперь, когда наше предложение хранится в переменной, давайте изменим слово, сохраненное в нем! Мы можем сделать это, выполнив функцию. Функции — это тип значения, который, в общем-то, служит для нас определенной функцией (целью или действием). Называть их «действиями» было бы странно, так что вместо этого использовали слово «функция».</p>

<p>В JavaScript есть функция <code>replace</code>, которая делает именно то, что мы хотим! Функции принимают любое количество значений в круглых скобках (ноль, одно или несколько) и возвращают либо <code>undefined</code>, либо измененную строку. </p>

<p>Функция <code>replace</code> доступна для использования с любыми строками и принимает два значения: символы, которые нужно вывести, и символы, которые нужно поменять местами. Звучит немного запутано, поэтому приведем наглядный пример:</p>

<div>
<figure><img src="images/console-replace.gif" alt="" class="img-fluid"></figure></div>


<p>Заметьте, что значение <code>dogSentence</code> одинаковое даже после того, как мы запустим команду <code>replace</code>? Это происходит потому, что функция <code>replace</code> (и большинство функций JavaScript в этом отношении) принимает значение, которое мы ей передаем, и возвращает новое значение без изменения значения, которое мы передали. Поскольку мы не сохранили результат (нет <code>=</code>) она просто возвращает значение в нашей консоли.</p>

<h2><span id="Standartnaa_biblioteka">«Стандартная библиотека»</span></h2>

<p>Вам может быть интересно, какие другие функции доступны в JavaScript. </p>

<p><strong>Ответ</strong>: очень много.</p>

<p>Есть много встроенных стандартных библиотек, о которых вы можете узнать в MDN (сайт, управляемый Mozilla, который имеет много полезной информации о веб-технологиях). Например, вот&nbsp;<a href="https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math" target="_blank" rel="noopener noreferrer">страница MDN</a>&nbsp;об объекте JavaScript Math.</p>

<h2><span id="Storonnij_JavaScript">Сторонний JavaScript</span></h2>

<p>Существует также много JavaScript-кода, который не является встроенным. JavaScript от третьих лиц обычно называют «библиотекой» или «плагином». Один из моих любимых называется <strong>Underscore.js</strong>. Давайте возьмем его и загрузим на нашу страницу!</p>

<p>Сначала перейдите на сайт Underscore (http://underscorejs.org), нажмите на ссылку для загрузки (я обычно использую версии для разработки, потому что они легче читаются, но и другие предоставляют вам одинаковую базовую функциональность).</p>

<p>Затем скопируйте весь код в буфер обмена (вы можете использовать <strong>Select All</strong> из меню <strong>Edit</strong>, чтобы выбрать все). Затем вставьте всё в консоль и нажмите <strong>Enter</strong>. Теперь в вашем браузере есть новая переменная: <code>_</code>.</p>

<div>
<figure><img src="images/underscore.gif" alt="" class="img-fluid"></figure></div>


<p>Подчеркивание дает вам массу полезных функций. Мы узнаем больше о том, как использовать их позже.</p>

<h2><span id="Sozdanie_novyh_funkcij">Создание новых функций</span></h2>

<p>Вы не ограничены использованием функций других людей — вы также можете писать их самостоятельно. Это довольно просто! Давайте создадим функцию <code>makeMoreExciting</code>, которая добавляет несколько восклицательных знаков в конец строки.</p>

<pre><code class="language-javascript">function makeMoreExciting(string) {
  return string + '!!!!'
}</code></pre>

<p>Т.е. существует функция, которая принимает строку и возвращает новую копию этой строки к которой добавляется несколько восклицательных знаков в конце.</p>

<p>Вот как мы могли бы написать это в консоли вручную, если бы мы не использовали функцию:</p>

<div>
<figure><img src="images/custom-function-manually.gif" alt="" class="img-fluid"></figure></div>

<p>Выражение <code>string + '!!!!'</code> возвращает новую строку, и наша переменная с именем <code>string</code> остается такой же, как и раньше (так как мы не обновляли с помощью <code>=</code>.</p>

<p>Давайте использовать нашу функцию вместо того, чтобы делать это вручную. Сначала вставьте функцию в консоль, а затем вызовите функцию, передав строку:</p>

<div>
<figure><img src="images/custom-function-call.gif" alt="" class="img-fluid"></figure></div>

<p>Вы также можете вызвать ту же функцию, передав переменную, которая указывает на строку (в приведенном выше примере мы просто ввели строку прямо в качестве значения вместо того, чтобы сначала сохранить ее в переменной):</p>

<div>
<figure><img src="images/custom-function-call-variable.gif" alt="" class="img-fluid"></figure></div>

<p>Строка <code>makeMoreExciting(выражение)</code> эквивалентна <code>выражение + '!!!!'</code>. Что, если мы хотим изменить на месте (или обновить) значение строки? Просто сохраните возвращаемое значение функции обратно в нашу переменную <code>выражения:</code></p>

<pre><code class="language-javascript">var sentence = "time for a nap"
sentence = makeMoreExciting(sentence)</code></pre>

<p>Теперь в строке будут восклицательные знаки! </p>

<div class="attention-yellow"><strong>Обратите внимание</strong>! Вы должны использовать <code>var</code> только при инициализации переменной — при первом использовании.</div>

<p>После этого вам не следует использовать <code>var</code>, если вы не хотите повторно инициализировать переменную.</p>

<p>Что произойдет, если мы уберем оператор <code>return</code> в нашей функции?</p>

<div>
<figure><img src="images/custom-function-no-return.gif" alt="" class="img-fluid"></figure></div>

<p>Почему <code>выражение</code> пустое? Потому что функции возвращает <code>undefined</code> по умолчанию! </p>

<p>Вы можете вернуть значение, написав <code>return</code>. Функции должны принимать значение и, если они изменяют значение или создают новое значение, которое предполагается использовать позже, возвращают <code>return</code> значение (забавный факт: причудливый термин для этого стиля — функциональное программирование). </p>

<p>Вот еще одна функция, которая ничего не возвращает, а использует другой метод, чтобы показать нам результат:</p>

<pre><code class="language-javascript">function yellIt(string) {
  string = string.toUpperCase()
  string = makeMoreExciting(string)
  console.log(string)
}</code></pre>

<p>Эта функция <code>yellIt</code> использует нашу предыдущую функцию <code>makeMoreExciting</code>, а также встроенный метод для строк (String) <code>toUpperCase</code>. </p>

<p>Методы — это просто имя функции, когда она принадлежит чему-то — в этом случае <code>toUpperCase</code> — это функция, которая принадлежит <code>string</code>, поэтому мы можем ссылаться на нее как на метод или функцию.</p>

<p>С другой стороны, <code>makeMoreExciting</code> не принадлежит никому, поэтому было бы технически некорректно ссылаться на него как на метод (я знаю, это сбивает с толку).</p>

<p>Последняя строка функции — это еще одна встроенная функция, которая просто принимает любые заданные вами значения и выводит их в консоль.</p>

<div>
<figure><img src="images/custom-function-console-log.gif" alt="" class="img-fluid"></figure></div>

<p>Может быть что-то не так с вышеуказанной функцией <code>yellIt</code>? Вот два основных типа функций:</p>

<ul>
<li>функции, которые изменяют или создают значения и возвращают их</li>
<li>функции принимают значения и выполняют некоторые действия, которые не могут быть возвращены</li>
</ul>

<p><code>console.log</code> является примером функции второго типа: она выводит данные в консоль — действие, которое вы можете увидеть своими глазами, но которое нельзя представить в виде значения JavaScript.</p>

<p>Мое эмпирическое правило состоит в том, чтобы попытаться отделить два типа функций друг от друга, поэтому вот как я бы переписал функцию <code>yellIt</code>:</p>

<pre><code class="language-javascript">function yellIt(string) {
  string = string.toUpperCase()
  return makeMoreExciting(string)
}

console.log(yellIt("i fear no human"))</code></pre>

<p>Таким образом, <code>yellIt</code> становится более общим, то есть он выполняет только одну или две простые задачи и ничего не знает о печати себя в консоли — эту часть всегда можно запрограммировать позже, вне определения функции.</p>

<h2><span id="Cikly">Циклы</span></h2>

<p>Теперь, когда у нас есть некоторые базовые навыки мы можем начать лениться. Что?! Да, верно. Программирование — это лень. Ларри Уолл, изобретатель языка программирования Perl, назвал лень самым важным достоинством хорошего программиста.</p>

<p>Если бы компьютеров не было, вам бы пришлось выполнять все утомительные задачи вручную, но если вы научитесь программировать, вы можете весь день лежать на солнце, пока компьютер где-то запускает ваши программы для вас. Это великолепный образ жизни, наполненный отдыхом!</p>

<p>Циклы являются одним из наиболее важных способов использования мощности компьютера. Помните <code>underscore.js</code>? </p>

<p>Убедитесь, что он загружен на странице (помните: вы можете просто нажать стрелку вверх на клавиатуре несколько раз, а затем нажать <code>Enter</code>, чтобы загрузить его снова, если вам нужно), и попробуйте скопировать/вставить это в консоль:</p>

<pre><code class="language-javascript">function logANumber(someNumber) {
  console.log(someNumber)
}
_.times(10, logANumber)</code></pre>

<p>В этом коде используется один из методов <code>underscore</code> под названием <code>times</code>, который принимает 1 число и 1 функцию, а затем начиная с 0 и до 10 прибавляет 1, вызывая функцию на каждом шаге.</p>

<div>
<figure><img src="images/times-loop.png" alt="" class="img-fluid"></figure></div>

<p>Если бы мы вручную выписывали то, что делает <code>times</code> в приведенном выше коде, это выглядело бы так:</p>


<pre><code class="language-bash">logANumber(0)
logANumber(1)
logANumber(2)
logANumber(3)
logANumber(4)
logANumber(5)
logANumber(6)
logANumber(7)
logANumber(8)
logANumber(9)</code></pre>

<p>Но кошки отказываются делать ненужную ручную работу как эта, поэтому мы всегда должны спрашивать себя: «Я делаю это самым ленивым способом?».</p>

<p>Так почему это называется зацикливанием? Подумайте об этом так: если бы мы записали список из 10 чисел (от 0 до 9) с использованием массива JavaScript, это выглядело бы так:</p>

<pre><code class="language-javascript">var zeroThroughTen = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]</code></pre>

<p>Что на самом деле делает <code>times</code> — переходит к каждому числу и повторяет задачу.</p>

<p>В приведенном выше примере задача состояла в том, чтобы вызвать функцию <code>logANumber</code> с текущим числом. Повторение задачи таким способом называется циклом с массивом.</p>

<h2><span id="Massivy">Массивы</span></h2>

<p>Я упоминал об этом несколько раз, но давайте потратим минуту, узнавая о них. Представьте, что вам нужно следить за всеми своими друзьями.</p>

<p>Использование массива будет хорошим решением. Думайте о массиве как об отсортированном списке, в котором вы можете хранить много вещей.</p>

<p>Вот как вы создаете массив:</p>

<pre><code class="language-javascript">var myCatFriends = ["bill", "tabby", "ceiling"]</code></pre>

<p>Классно! Теперь у вас есть список ваших друзей.</p>

<p>Элементы (это то, что вы называете отдельным элементом в массиве), которые хранятся в массивах, начинаются и отсчитываются с 0. Таким образом, <code>myCatFriends[0]</code> возвращает <code>bill</code>, а <code>myCatFriends[1]</code> возвращает <code>tabby</code> т.д.</p>

<p>Чтобы вывести друзей в консоль из вашего нового массива, вы можете просто получить доступ к элементу, например, так:</p>

<pre><code class="language-javascript">console.log(myCatFriends[0])</code></pre>

<div>
<figure><img src="images/array-access.png" alt="" class="img-fluid"></figure></div>

<p>Если у вас появился друг и вы хотите добавить его в свой список, то это очень просто: <code>myCatFriends.push("super hip cat")</code>.</p>

<p>Чтобы проверить, что новый друг попал в ваш массив, вы можете использовать <code>.length</code>:</p>

<div>
<figure><img src="images/array-push-length.png" alt="" class="img-fluid"></figure></div>

<p>Обратите внимание, как <code>push</code> вернул длину? Удобно! Также обратите внимание, что массивы всегда сохраняют порядок, что означает, что они будут помнить порядок, в котором вы добавили или определили вещи.</p>

<p>Не все в JavaScript сохраняет порядок, так что запомните это специальное свойство массивов!</p>

<h3><span id="Udalenie_dublikatov_iz_massiva">Удаление дубликатов из массива</span></h3>

<p>Этот трюк довольно прост. Предположим, у меня есть массив, содержащий числа, строки и логические значения. И я хочу убедиться, что в этом массиве нет повторяющихся элементов. Как это сделать?</p>

<pre><code class="language-javascript">const array = [1, 2, 3, 2, 1, true, true, false, 'Ratul', 1, 5];
const filtered__array = [...new Set(array)];
console.log(filtered__array) // [ 1, 2, 3, true, false, 'Ratul', 5 ]</code></pre>

<h3><span id="Polucenie_poslednego_znacenia_massiva">Получение последнего значения массива</span></h3>

<p>Предположим, у вас есть массив. Что нам делать, если мы хотим получить последний элемент этого массива?</p>

<pre><code class="language-javascript">const array = [1, 2, 3, 4, 5]
const last_Item = array.slice(-1)
console.log(last_Item)</code></pre>

<p>Если вы поставите -2 вместо -1, то получите два последних значения массива, а затем, если вы укажете -3 вместо -2, то получите значения трех последних индексов и так далее.</p>

<h3><span id="Polucenie_slucajnogo_znacenia_indeksa_iz_massiva">Получение случайного значения индекса из массива</span></h3>

<p>Предположим, мы проводим лотерею. У нас есть массив, содержащий имена участников. </p>

<p>Теперь мы хотим, чтобы только один пользователь случайным образом из массива был определен победителем.</p>

<pre><code class="language-javascript">const participants = ['Ratul', 'George', 'july', 'Padrik', 'G']
const winner = participants[Math.floor(Math.random() * participants.length)]
console.log(winner) // july</code></pre>

<h3><span id="Obnaruzenie_samogo_dlinnogo_slova_v_massive">Обнаружение самого длинного слова в массиве</span></h3>

<p>Создайте массив и добавьте несколько разных строк. Теперь выведите самую длинную строку этого массива.</p>

<pre><code class="language-javascript">const array = ['Apple', 'Pine-apple', 'Banana', 'Jack-fruit']

let most_lengthy_string = ''
array.forEach((item) =&gt; {
  if (item.length &gt; most_lengthy_string.length) {
    most_lengthy_string = item
  }
})
console.log(most_lengthy_string)</code></pre>

<p>Довольно простой подход. Во-первых, у нас есть массив, содержащий несколько строк. И после этого я создал переменную, содержащую пустую строку.</p>

<p>Теперь, чтобы обнаружить самую длинную строку в этом массиве, мне нужно посмотреть все элементы массива.</p>

<p>Если длина элемента массива больше, чем длина нашей переменной <code>most_lengthy_string</code>, то мы переназначаем значение переменной, и, в конце концов, выводим найденную переменную.</p>

<p>Еще один вариант предложенный пользователем сайта для определения самого длинного слова в массиве:</p>

<pre><code class="language-javascript">const mostLengthy = someArray
    .reduce((acc, i) =&gt;
        i.length &gt; acc.length
             ? i
             : acc
)</code></pre>

<h2><span id="Obekty">Объекты</span></h2>

<p>Массивы хороши для списков, но для других задач с ними может быть сложно работать. Рассмотрим наш массив друзей. Что, если вы также хотите хранить больше, чем просто имена?</p>

<pre><code class="language-javascript">var myCatFriends = ["bill", "tabby", "ceiling"]
var lastNames = ["the cat", "cat", "cat"]
var addresses = ["The Alley", "Grandmas House", "Attic"]</code></pre>

<p>Иногда полезно иметь все адреса или имена в одной переменной. В нашем примере, например, мы хотим для одного друга посмотреть его адрес.</p>

<p>С массивами потребуется много работы, потому что вы не можете просто сказать «эй, массив, дай мне адрес Билла», потому что «Билл» находится в одном массиве, а его адрес — в совершенно другом массиве.</p>
<div>

<figure><img src="images/array-lookup.png" alt="" class="img-fluid"></figure></div>

<p>Всё это очень ненадежно, потому что если наши массивы изменятся и мы добавим в начало нового друга, нам также придется обновить нашу переменную <code>billsPosition</code>, чтобы указать информацию о новом местоположении Билла в массивах! </p>

<p>Вот более простой способ хранения информации с использованием объектов:</p>

<pre><code class="language-javascript">var firstCat = { name: "bill", lastName: "the cat", address: "The Alley" }
var secondCat = { name: "tabby", lastName: "cat", address: "Grandmas House" }
var thirdCat = { name: "ceiling", lastName: "cat", address: "Attic" }</code></pre>

<p>Зачем нам так делать? Потому что теперь у нас есть переменная для каждого друга, которую мы можем использовать для получения данных более удобным и удобочитаемым способом.</p>

<div>
<figure><img src="images/object-lookup.png" alt="" class="img-fluid"></figure></div>

<p>Вы можете думать об объектах как о ключах на связке ключей. Каждый из них предназначен для конкретной двери, и если у вас есть красивые наклейки на ваших ключах, вы можете открыть двери очень быстро.</p>

<p>Фактически, слева от <code>:</code> — ключи (или свойства), а справа — значения. В английском — это keys, properties и values.</p>

<pre><code class="language-javascript">// an object with a single key 'name' and single value 'bill'
{ name: 'bill' }</code></pre>

<p>Так зачем использовать массивы, если можно просто поместить свои данные в объекты? Потому что объекты не помнят порядок ключей, которые вы установили. Вы можете ввести в объект:</p>

<pre><code class="language-javascript">{ date: "10/20/2012", diary: "slept a bit today", name: "Charles" }</code></pre>

<p>Но компьютер может вернуть вам так:</p>

<pre><code class="language-javascript">{ diary: "slept a bit today", name: "Charles", date: "10/20/2012" }</code></pre>

<p>Или так:</p>

<pre><code class="language-javascript">{ name: "Charles", diary: "slept a bit today", date: "10/20/2012" }</code></pre>

<p>Таким образом, вы никогда не можете доверять порядку ключей в объектах.</p>

<p>Если вы хотите получить действительно что-то интересное, то вы можете создать массив, заполненный объектами, или объект, заполненный массивами!</p>

<pre><code class="language-javascript">var moodLog = [
  {
    date: "10/20/2012",
    mood: "catnipped"
  }, 
  {
    date: "10/21/2012",
    mood: "nonplussed"
  },
  {
    date: "10/22/2012",
    mood: "purring"
  }
]

// ordered from least to most favorite
var favorites = {
  treats: ["bird sighting", "belly rub", "catnip"],
  napSpots: ["couch", "planter box", "human face"]
}</code></pre>

<p>Когда вы объединяете разные вещи таким образом, то вы создаете структуры данных, как лего!</p>

<h2><span id="Callbacks">Callbacks</span></h2>

<p>Callbacks (или обратные функции) — это на самом деле не опция JavaScript, как <code>Object</code> (объект) или <code>Array</code> (массив), а просто определенный способ использования функций.</p>

<p>Чтобы понять, почему обратные вызовы или функции полезны, вы сначала должны узнать об асинхронном программировании. </p>

<p>Асинхронный код по определению — это код, написанный не синхронно. Синхронный код легко понять и написать. Вот пример для иллюстрации:</p>

<pre><code class="language-javascript">var photo = download('http://foo-chan.com/images/sp.jpg')
uploadPhotoTweet(photo, '@maxogden')</code></pre>

<p>Этот синхронный псевдокод скачивает очаровательную фотографию кота, а затем загружает фотографию в твиттер и отправляет ее на <strong>@maxogden</strong>. Довольно просто!</p>

<p>Этот код является синхронным, потому что для загрузки фотографии в твиттер, скачивание фотографии должно быть завершено. Это означает, что строка 2 не может выполняться, пока задача в строке 1 не будет полностью завершена.</p>

<p>Если бы мы на самом деле реализовали этот псевдокод, мы бы хотели убедиться, что загрузка «заблокирована», пока скачивание не будет завершено, что предотвратит выполнение любого другого JavaScript-кода до его завершения.</p>

<p>А затем, когда скачивание завершится, будет разблокировано выполнение JavaScript, и строка 2 будет выполнена.</p>

<p>Синхронный код хорош для вещей, которые происходят быстро, но ужасен для вещей, которые требуют сохранения, загрузки, скачивания или выгрузки.</p>

<p>Что если сервер, с которого вы загружаете фотографию, работает медленно, или интернет-соединение, которым вы пользуетесь, работает медленно, или на компьютере, на котором вы запускаете код, слишком много открытых вкладок с youtube и он работает медленно?</p>

<p>Это означает, что потенциально может занять несколько минут ожидания, прежде чем строка 2 приступит к работе. Между тем, поскольку весь JavaScript на странице блокируется от запуска во время загрузки, веб-страница полностью зависает и перестает отвечать до завершения скачивания.</p>

<p>Следует избегать блокирования выполнения любой ценой, особенно если это приводит к зависанию вашей программы. Предположим, что фотография выше скачивается за одну секунду.</p>

<p>Чтобы проиллюстрировать, сколько времени занимает одна секунда для современного компьютера, вот программа, которая проверяет, сколько задач JavaScript может обработать за одну секунду.</p>

<pre><code class="language-javascript">function measureLoopSpeed() {
  var count = 0
  function addOne() { count = count + 1 }

  // Date.now() returns a big number representing the number of
  // milliseconds that have elapsed since Jan 01 1970
  var now = Date.now()

  // Loop until Date.now() is 1000 milliseconds (1 second) or more into
  // the future from when we started looping. On each loop, call addOne
  while (Date.now() - now &lt; 1000) addOne() // Finally it has been &gt;= 1000ms, so let's print out our total count
  console.log(count)
}

measureLoopSpeed()</code></pre>

<p>Скопируйте и вставьте приведенный выше код в консоль JavaScript, и через секунду он должен вывести число. На моем компьютере я получил <code>8527360</code>, примерно 8,5 миллионов.</p>

<p>За одну секунду JavaScript может вызвать функцию <code>addOne</code> 8,5 миллионов раз! Таким образом, если у вас есть синхронный код для скачивания фотографии, а загрузка фотографии занимает одну секунду, это означает, что вы потенциально предотвращаете выполнение 8,5 миллионов операций, когда выполнение JavaScript заблокировано.</p>

<p>В некоторых языках есть функция <code>sleep</code>, которая блокирует выполнение на некоторое количество секунд. Например, вот некоторый код <code>bash</code>, работающий в <code>Terminal.app</code> в Mac OS, который использует <code>sleep</code>. </p>

<p>Когда вы запускаете команду <code>sleep 3 &amp;&amp; echo 'done sleep now'</code>, она блокируется на 3 секунды, прежде чем выведет <code>'done sleep now'</code>.</p>

<div>
<figure><img src="images/bash-sleep.png" alt="" class="img-fluid"></figure></div>

<p>У JavaScript нет функции <code>sleep</code> (сна). Вероятно, вы спрашиваете себя: «Почему я изучаю язык программирования, который не подразумевает сон?».</p>

<p>Вместо того, чтобы полагаться на сон, чтобы подождать, когда что-то произойдет, JavaScript поощряет использование функций. Если вам нужно дождаться завершения задачи A, прежде чем выполнять задачу B, вы помещаете весь код задачи B в функцию и вызываете эту функцию только после завершения A.</p>

<p>Например, это код в стиле блокировки:</p>

<pre class="language-javascript"><code>a()
b()</code></pre>

<p>А этом в неблокирующем стиле:</p>

<pre><code class="language-javascript">a(b)</code></pre>

<p>В неблокирующей версии <code>b</code> это обратный вызов <code>a</code>. В блокирующей версии <code>a</code> и <code>b</code> оба вызываются (они обе имеют <code><strong>()</strong></code> после них, что немедленно выполняет функцию). В неблокирующей версии вы заметите, что вызывается только a, а b просто передается в качестве аргумента.</p>

<p>В версии блокировки нет явной связи между <code>a</code> и <code>b</code>. В неблокирующей версии это становится задачей <code>a</code> делать то, что нужно, а затем вызывать <code>b</code>, когда это будет сделано.</p>

<p>Использование функций таким способом называется обратным вызовом, потому что ваша функция обратного вызова, в данном случае <code>b</code>, вызывается позже, когда все выполнено.</p>

<p>Вот псевдокод реализации того, как <code>a</code> может выглядеть:</p>

<pre><code class="language-javascript">function a(done) {
  download('https://pbs.twimg.com/media/B4DDWBrCEAA8u4O.jpg:large', function doneDownloading(error, png) {
    // handle error if there was one
    if (err) console.log('uh-oh!', error)

    // call done when you are all done
    done()
  })
}</code></pre>

<p>Вспомните наш неблокирующий пример <code>a(b)</code>, где мы вызываем <code>a</code> и передаем <code>b</code> в качестве первого аргумента. В определении функции для <code>a</code> над <code>done</code> наша функция <code>b</code>, которую мы передаем. Такое поведение сначала сложно понять.</p>

<p>Когда вы вызываете функцию <code>a</code>, передаваемые аргументы не будут иметь одинаковые имена переменных, когда они находятся в функции. В этом случае то, что мы называем <code>b</code>, называется <code>done</code> внутри функции.</p>

<p>Но <code>b</code> и <code>done</code> — это просто имена переменных, которые указывают на одну и ту же базовую функцию. Обычно функции обратного вызова помечаются чем-то вроде <code>done</code> или <code>callback</code>, чтобы прояснить, что они являются функциями, которые должны вызываться при выполнении текущей функции.</p>

<p>Таким образом, до тех пор, пока <code>a</code> выполняет свою работу и вызывает <code>b</code> по завершении, <code>a</code> и <code>b</code> будут вызываться как в неблокирующей, так и в блокирующей версиях.</p>

<p>Разница в том, что в неблокирующей версии нам не нужно останавливать выполнение JavaScript. В общем, неблокирующий стиль — это то, где вы пишете каждую функцию, чтобы она могла вернуть значение (<code>return</code>) как можно скорее, без каких-либо блокировок.</p>

<p>Если <code>a</code> занимает одну секунду и вы используете блокирующую версию, это означает, что вы можете выполнить только одну задачу.</p>

<p>Если вы используете неблокирующую версию (также называемую обратным вызовом или обратной функцией), вы можете делать буквально миллионы других вещей за ту же секунду, что означает, что вы можете закончить свою работу в миллионы раз быстрее и спать до конца дня.</p>

<p><strong>Помните</strong>: программирование — это про лень, и вы должны спать, а не сидеть за компьютером.</p>

<p>Надеюсь, теперь вы увидели, что обратные функции — это просто функции, которые вызывают другие функции после некоторой асинхронной задачи.</p>

<p>Типичными примерами асинхронных задач являются такие вещи, как чтение фотографии, загрузка песни, загрузка изображения, общение с базой данных, ожидание нажатия пользователем клавиши и т.д.</p>

<p>Все, что занимает время. JavaScript действительно хорошо справляется с асинхронными задачами, подобными этим, если вы потратите время на то, чтобы научиться использовать обратные функции и предотвращать блокировку исполнения JavaScript-кода.</p>

<h2><span id="Snippety">Сниппеты</span></h2>

<p>Короткие фрагменты кода (сниппеты), которые помогают решать какие-либо задачи в JavaScript.</p>

<h3><span id="Proveraem_susestvovanie_funkcii">Проверяем существование функции</span></h3>

<p>Проверяем существование функция перед ее вызовом.</p>

<p>Всегда неприятно, когда вы получаете сообщение об ошибке при попытке вызвать функцию, которая не была определена, но есть простой способ предотвратить это. Чтобы проверить, существует ли функция Javascript перед ее вызовом, попробуйте этот сниппет.</p>

<pre><code class="language-javascript">if (typeof yourFunctionName == 'function')
{
 yourFunctionName(); 
}</code></pre>

<h3><span id="Zamenaem_element_massiva">Заменяем элемент массива</span></h3>

<p>Если у нас есть массив и нам известен индекс элемента, то мы можем заменить его содержимое простым присваиванием:</p>

<pre><code class="language-javascript">const items = ['a', 'b', 'c', 'd', 'e', 'f']
const i = 2

items[i] = '--NEW-ITEM--'

console.log(items)
//[ 'a', 'b', '--NEW-ITEM--', 'd', 'e', 'f' ]</code></pre>

<p>Если вы не знаете индекса элемента, то, возможно, сначала вам понадобится найти индекс элемента массива.</p>

<h2><span id="Zaklucenie">Заключение</span></h2>

<p>Это только начало ваших взаимоотношений с JavaScript! Вы не сможете изучить все это сразу, но вы должны найти то, что работает для вас, и попытаться изучить все концепции.</p>

<p>Я бы порекомендовал вернуться сюда завтра и снова пройти через все это с самого начала! Может понадобиться несколько раз, прежде чем вы осознаете всё это (программирование довольно сложная штука в самом начале).</p>

<p>JavaScript – это динамический язык программирования. Он легкий и чаще всего используется как часть веб-страниц, реализации которых позволяют клиентскому сценарию взаимодействовать с пользователем и создавать динамические страницы.</p>

<p>Это интерпретируемый язык программирования с объектно-ориентированными возможностями.</p>
			
		</div>
	</div>
</div>
<div class="container">
	<div class="row">
		<div class="col-12 col-md-7">
			<div class="mb-3 mb-mb-4 d-flex gap-3">
				<div>
					<img alt="Сергей Ермилов" src="../../assets/images/sergei-450.png" height="68" width="68">
				</span>
				</div>
				<div>
					<a href="../../about/" class="link-dark link-offset-2 link-underline-opacity-25 link-underline-opacity-100-hover">Сергей Ермилов</a><br>
					<span>Дизайнер, верстальщик, фронтенд-разработчик, PHP и WordPress энтузиаст, главный редактор сайта</span>
				</div>
			</div> 
		</div>
		<div class="col-12 col-md-5">
			<span class="text-muted">Опубликовано 30 июня 2022 в 10:00</span><br>Теги: JavaScript
		</div>
	</div>
</div>

<!-- ------------ -->
<!-- START FOOTER -->
<!-- ------------ -->
<footer class="py-5">
	<div class="container">
		<div class="row">
			<div class="col-12 col-md-4 my-auto">
				<span class="fw-500 text-muted">SergeiErmilov</span>
			</div>
			<div class="col-12 col-md-4 text-center my-auto">
				<img src="../../assets/images/sergei-150.png" alt="Sergei Ermilov" width="80" height="80">
			</div>
			<div class="col-12 col-md-4 my-auto text-end">
				<span class="fw-500 text-muted">&copy; 2008-<script>document.write(new Date().getFullYear())</script></span>
			</div>
		</div>
	</div>
</footer>

	<script src="../../assets/js/bootstrap.bundle.min.js"></script>
	<script src="../../assets/js/app.js"></script>
	<script src="../../assets/js/prism.js"></script>	

  </body>
</html>